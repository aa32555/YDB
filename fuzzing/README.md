# Fuzzing

This directory contains everything you need to begin fuzzing YDB.  This script fuzzes YottaDB in direct mode on `nproc - 2` cores using the tests generated by YDB.

## Setup

This script assumes you have tmux installed (`apt install tmux -y` or similar for your repo), and AFL++ installed in your PATH.  AFL++ can be found at https://github.com/AFLplusplus/AFLplusplus.

You also have to run `echo core >/proc/sys/kernel/core_pattern` *as root* before you call `make`!

## Running it

You should only have to call `make`.  The makefile in this directory should handle everything else, and afterwards you can run `tmux ls` to check for running fuzzing instances.

You can gather the crashing inputs by navigating to `output` and then for example to `Leader` and finally `crashes`.

## How does this work?

At a high level, we've only made a makefile which calls three scripts in this directory to set up the env and make things work for us.  Each of those are worth a little discussion, however.

### Instrumentation

To fuzz something, we first need to have AFL be able to track execution, etc.  This means, of course, instrumentation.  To do that we need to make two small changes to the build process:

1. We patch out the signal handlers installed for SIGBUS, SIGSEGV, SIGILL, SIGFPE, etc in `sr_unix/sig_init.c`.  This is a one line change that we do with `patch`.

2. We change CC and CXX to use `afl-clang-fast`/`afl-gcc-fast` and `afl-clang-fast++`/`afl-g++-fast` from the system path depending on whether the clang or gcc version of afl is available.

3. We then build/instrument YottaDB.

4. And finally undo the patches done in Step 1.

This is all handled inside of `instrument.sh`.

### Corpus creation

To create the corpus (and to minimize the size of these changes), we clone the YDBTests repository, copy all the individual test cases into a new directory, and then run `afl-cmin` to make sure there's no duplicates, and then use that as the input to fuzzing.

This is handled in `make_corpus.sh`.

### Fuzzing it

Finally, we fuzz!  For ease, what we do here is start a bunch (technically `nproc` - 2) of tmux sessions, each of which is running an afl-fuzz session.  Then, to check if things are running you can list the sessions (`tmux ls`), attach to a session (`tmux a -t Leader` for example), and then see the AFL main screen.  Finally, if you wanna see what's going on globally, you can run `afl-whatsup output` from the root of the fuzzing directory to get a look at everything at once.

This is in `fuzz.sh`.

## How do I...

### ...turn it off?

Just kill the tmux server (`tmux kill-server`).

### ...restart it?

On modern version of AFL++, you can remove the input directory to make `afl-fuzz` read from the input queue instead of from an input corpus.  Simply remove `-i inputs` from fuzz.sh, and replace it with `-i-`.  Then, rerun all the fuzzers by just calling `./fuzz.sh`.

## Issues

- Fuzzing YDB like this creates a LOT of trash files all over the place.  Its not _that_ common, but its worth pointing out.  We get around this by running a helper script which deletes ./env/\* every once in a while, but a true fix for this would involve further patches to YDB that might shadow bugs, which we want to avoid.

- You _might_ have an issue with random crashes, which has been seen during earlier campaigns.  What appears to happen is that one of the scripts effectively calls `chmod 000 env`, which then causes every AFL fuzzer to crash because it can't write to the directory.  You can pre-emptively fix this by calling `chmod 777 env; chown root:root env`, if desired.

## FAQ

- Who is responsible for this mess?
  - Zachary Minneker from Security Innovation in Seattle, WA! Check us out at securityinnovation.com!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;								;
; Copyright (c) 2021 YottaDB LLC and/or its subsidiaries.	;
; All rights reserved.						;
;								;
;	This source code contains the intellectual property	;
;	of its copyright holder(s), and is made available	;
;	under a license.  If you do not know the terms of	;
;	the license, please stop and do not read further.	;
;								;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%YDBAIM
	; Top level entry not supported
	do etrap		; set error trap
	set $ecode=",U255,"	; top level entry not supported
	quit			; should never get here

err	; Error handler
	new stderr,tmp1,tmp2
	set tmp1=$zpiece($ecode,",",2),tmp2=$text(@tmp1)
	set:'$zlength(tmp2) tmp2=$text(U251)
	set stderr="/proc/self/fd/2"
	open stderr
	use stderr
	write $text(+0),@$zpiece(tmp2,";",2,$zlength(tmp2,";")),!
	zhalt +$extract(tmp1,2,$zlength(tmp1))

; Set error trap. The first action the error trap does is set a failsafe error
; trap (e.g., if $zroutines is not correct). Thereafter, it jumps to the actual
; error trap to print an error message and terminate, with a return code.
etrap
	set $etrap="set $etrap=""open """"/proc/self/fd/2"""" use """"/proc/self/fd/2"""" write $zstatus,! zshow """"*"""" zhalt 1""  goto err^"_$text(+0)
	quit

; Creates triggers to maintain cross references and computes cross references
; for a global variable at a specified subscript level. Concurrent execution OK.
;
; Usage: $$XREFDATA^%YDBAIM(gbl,nsubs,sep,pnum,nmonly,zpiece)
; Parameters:
; - gbl is the global variable name, e.g., "^ABC"
; - nsubs is the number of subscripts at the level for which the xref is desired
; - sep is the piece separator for values at that node; if unspecified or the
;   empty string, xref is for entire nodes
; - pnum is a semi-colon separated list of integer piece numbers for which cross
;   references should exist; ignored for xrefs of entire node values effectively
;   a no-op if pieces specified are already cross-referenced
; - nmonly, if 1, means just return the xref global variable name but don't set
;   triggers or compute xrefs
; - zpiece, if 1 means that $ZPIECE() should be used as the piece separator instead
;   of $PIECE(); AIM can have cross references for the same nodes with both
;   options; the cross references are in different global variables
; Return value: name of global variable with cross reference
; e.g., "^%ydbAIMDZzUmfwxt80MHPiWLZNtq4"
;
; The function is coded so that the function tries as efficiently as possible
; whether the cross referecing is already done. This means that it is not
; unreasonable to just call the function to ensure that the cross reference
; exists, without the caller first checking whether it already exists.
; Since the function uses $PIECE(), sep is interpreted according to whether the
; process is in M mode or UTF-8 mode.  While cross references for entire nodes
; are the same for M and UTF-8 modes, there are separate cross references for
; pieces of nodes.  Cross references are in global variables such as
; ^%ydbAIMDZzUmfwxt80MHPiWLZNtq4, which are derived from a prefix of "^%ydbAIMD"
; and a suffix of a 128-bit hash of the variable name, number of subscripts,
; whether $ZPIECE() or $PIECE() are used to locate pieces, and, if it is
; $PIECE(), then $ZCHSET. Thus, there are four possible xref variable names.
;   1. xref the entire value at global variable nodes.
;   2. xref pieces, byte-oriented piece separator - $ZPIECE()
;   3. xref pieces, M mode, char-oriented piece separator, $PIECE()
;   4. xref pieces, UTF-8 mode, char-oriented piece separator, $PIECE()
; Note: 2. and 3. will result in the same cross references, but the
; xref global variable names and trigger definitions differ.
; As the hash is the 128-bit MurMurHash, a non-cryptographic hash with
; excellent statistical properties, that is rendered into a valid global
; variable name suffix with $ZYSUFFIX().
; The subscripts of cross reference variables are:
; - (pnum,value,sub[,sub]) where pnum is a positive integer for cross references
;   of pieces of nodes; and
; - (value,sub[,sub]) for cross references of entire nodes.
; A limitation of this technique is that the values being cross referenced plus
; the subscripts must have a total length within the limit of YottaDB global
; keys (currently 1019 bytes).
; The approach is to first create triggers to maintain cross references, and
; then scan the global variable to generate cross references. This way, any
; global variable changes will have cross references maintained by the triggers,
; and when returning to caller, the cross reference is complete, and will remain
; Consistent thereafter.  ^%ydbAIMD* global variables should be mapped to a
; region with NULL_SUBSCRIPTS set to EXISTING or ALWAYS.
; Just as cross references are metadata for application global variables,
; metadata for the cross reference global variables are stored in the xref
; global variables as follows:
; - root node is the application global variable; subscripted nodes are:
; - (0) space separated $zut, $job, $zyrelease
; - (1) number of subscripts of the application global variable xref'd
; - (2) piece separator, "" for an xref of entire nodes
; - (3) & (4) piece numbers, in the form of a bit-map like string,
;    prefixed with "#" to prevent numeric conversion, e.g., the value for
;    pieces 2, 4 and 5 would be "#01011", "" for an xref of the entire node.
;    (3) identifies the piece numbers for which cross referencing is complete
;    whereas (4) identifies those for which triggers exist. If they are not
;    equal, it means that a process created triggers, but is still working on
;    cross referencing existing global nodes. It is also possible that the
;    process has terminated. When deleting triggers.
; - (5) 1 means $ZPIECE() should be used for pieces; default is $PIECE()
; - (6) SET trigger for this cross reference
; - (7) KILL trigger for this cross reference
; - (8) ZKILL trigger for this cross reference
; Since the cross references themselves must have at least two subscripts, any
; node with one subscript is metadata for the cross reference.
XREFDATA(gbl,nsubs,sep,pnum,nmonly,zpiece)
	new i,io,j,modflag,name,newpnum,newpstr,oldpstr,stderr,sub,tmp,trigdel,trigdelx,trigprefix,trigset,trigsub,trigsuffix,z
	set io=$io
	set stderr="/proc/self/fd/2" open stderr
	view "ztrigger_output":0
	; Extended references are not supported
	set:""'=$qsubscript(gbl,-1) $ecode=",U254,"
	; Xrefs are only supported for global variables
	set:"^"'=$zextract(gbl,1) $ecode=",U252,"
	; Coerce number of subscripts to a number
	set nsubs=+$get(nsubs)
	; Must have at least one subscript to xref
	set:+$get(nsubs)<1 $ecode=",U253,"
	; Derive subscript specification for trigger definitions from parameters
	set sub="sub1",trigsub="sub1=:"
	for i=2:1:nsubs set tmp=",sub"_i,sub=sub_tmp,trigsub=trigsub_tmp_"=:"
	set sep=$get(sep),zpiece=+$get(zpiece),z=$select(zpiece:"z",1:"")
	set name="^%ydbAIMD"_$zysuffix(gbl_nsubs_$select(zpiece:1,1:$select($zlength(sep):$zchset,1:"")))
	quit:+$get(nmonly) name				; Caller only wants name
	; Common prefix for all triggers
	set trigprefix="+"_gbl_"("_trigsub_") -command="
	; Put additional trigger options like " -noisolation" here when validated
	set trigsuffix=""
	; Determine whether to xref pieces or entire node, and act accordingly
	if $zlength(sep) do				; xref pieces
	. set:'$zlength($get(pnum)) $ecode=",U250,"
	. ; Make any trigger updates needed
	. tstart ()
	. set oldpstr=$get(@name@(4),"#"),modflag=0
	. set newpstr=$$unravel(pnum)
	. for i=2:1:$zlength(newpstr) set:+$zextract(oldpstr,i)'=+$zextract(newpstr,i) ($zextract(newpstr,i),modflag)=1
	. set:modflag&($zlength(oldpstr)>$zlength(newpstr)) $zextract(newpstr,i+1,$zlength(oldpstr))=$zextract(oldpstr,i,$zlength(oldpstr))
	. do:modflag
	. . set newpnum=$$ravel(newpstr)
 	. . set trigset=trigprefix_"set -xecute=""for i=1:1:$zlength($ztupdate,"""","""") set p=$piece($ztupdate,"""","""",i) zkill:$data("_name_"(p,$"_z_"piece($ztoldval,$ztdelim,p),"_sub_"))#10 ^(sub"_nsubs_") set:'$data("_name_"(p,$"_z_"piece($ztvalue,$ztdelim,p),"_sub_")) ^(sub"_nsubs_")="""""""""" -pieces="_newpnum_" -"_z_"delim="_$zwrite(sep)_trigsuffix
	. . set trigdel=trigprefix_"kill -xecute=""set p="_name_"(2) for i=2:1:$zlength("_name_"(4)) if +$zextract("_name_"(4),i) set j=i-1 kill:$data("_name_"(j,$"_z_"piece($ztoldval,p,j),"_sub_")) ^(sub"_nsubs_")"""_trigsuffix
	. . set trigdelx=trigprefix_"zkill -xecute=""set p="_name_"(2) for i=2:1:$zlength("_name_"(4)) if +$zextract("_name_"(4),i) set j=i-1 zkill:$data("_name_"(j,$"_z_"piece($ztoldval,p,j),"_sub_"))#10 ^(sub"_nsubs_")"""_trigsuffix
	. . for i=6:1:8 if $zlength($get(@name@(i)))&$ztrigger("item","-"_$zextract(^(i),2,$zlength(^(i))))
	. . set @name@(4)=newpstr,^(5)=z,^(6)=trigset,^(7)=trigdel,^(8)=trigdelx
	. . if $ztrigger("item",trigset)&$ztrigger("item",trigdel)&$ztrigger("item",trigdelx)
	. tcommit
	. ; Cross reference existing nodes, if needed. Note that even if this
	. ; process set triggers, another concurrent process might have
	. ; needed cross referenced the pieces this process wants xref'd.
	. set oldpstr=$get(@name@(3),"#"),modflag=0
	. for i=2:1:$zlength(newpstr) if +$zextract(newpstr,i)&'+$zextract(oldpstr,i) set modflag=1 quit
	. do:modflag
	. . do xrefdata(name,gbl,nsubs,sep,newpstr,zpiece)
	. . ; Update medatadata
	. . tstart ()
	. . set @name=gbl,@name@(0)=$zut_" "_$job_" "_$zyrelease,^(1)=nsubs,^(2)=sep
	. . set oldpstr=$get(^(3),"#")
	. . for i=2:1:$zlength(newpstr) set $zextract(oldpstr,i)=$select(+$zextract(newpstr,i):1,1:+$zextract(oldpstr,i))
	. . set ^(3)=oldpstr
	. . tcommit
	else  do:11'=$data(@name)		; No piece separator specified; xref entire node
	. set trigset=trigprefix_"set -xecute=""zkill:$data("_name_"($ztoldval,"_sub_"))#10 ^(sub"_nsubs_") set:'$data("_name_"($ztvalue,"_sub_")) ^(sub"_nsubs_")="""""""""""_trigsuffix
	. set trigdel=trigprefix_"kill -xecute=""kill:$data("_name_"($ztoldval,"_sub_")) ^(sub"_nsubs_")"""_trigsuffix
	. set trigdelx=trigprefix_"zkill -xecute=""zkill:$data("_name_"($ztoldval,"_sub_"))#10 ^(sub"_nsubs_")"""_trigsuffix
	. tstart ()
	. if $ztrigger("item",trigset)&$ztrigger("item",trigdel)&$ztrigger("item",trigdelx)
	. tcommit
	. do xrefdata(name,gbl,nsubs,"","","")
	. ; Add metadata to indicate completion
	. tstart ()
	. set @name=gbl,@name@(0)=$zut_" "_$job_" "_$zyrelease,^(1)=nsubs,(^(2),^(3),^(4),^(5))=""
	. set ^(6)=trigset,^(7)=trigdel,^(8)=trigdelx
	. tcommit
	quit name

; This label is interned to only be called internally. It is the inverse of the
; unravel() function. ravel() takes a bit-map like piece number string, e.g.,
; "#0010100111", and composes from it the compact form suitable for input to a
; trigger specification, e.g, "3;5;8:10" for the example above.
ravel:(pstr)
	new i,j,newpspec,nextp
	set newpspec=""
	set i=2 for  do  quit:i>$zlength(pstr)
	. if $zextract(pstr,i) do
	. . set nextp=i-1 if $increment(i)
	. . for j=i:1 quit:j>$zlength(pstr)!('$zextract(pstr,j))  set:$increment(i) $zpiece(nextp,":",2)=j-1
	. . set newpspec=newpspec_$select($zlength(newpspec):";",1:"")_nextp
	. else  if $increment(i)
	quit newpspec

; This label is intended to only be called internally. It takes a piece number
; specification, e.g., "3;5;8:10" and returns the bit-map like piece
; specification, preceded by "#", e.g., "#0010100111" for the example above.
; and determines if there are new pieces to xref. Pieces are separated by
; semi-colons. Each piece can be a number, or two colon separated numbers, with
; the first number smaller than the second. Unraveled piece numbers are in a
; bit-map like string, prefixed with "#".
unravel:(pnum)
	new i,newpstr,nextp,nextp1,nextpl,nextplen,nextpu
	set modflag=0,newpstr="#"
	for i=1:1:$zlength(pnum,";") do
	. set nextp=$zpiece(pnum,";",i),nextplen=$zlength(nextp,":")
	. if 1=nextplen do
	. . set:nextp\1'=nextp!(nextp<=0) $ecode=",U248,"
	. . set nextp1=nextp+1
	. . set:nextp1>$zlength(newpstr) newpstr=newpstr_$ztranslate($justify("",nextp1-$zlength(newpstr))," ",0)
	. . set $zextract(newpstr,nextp1)=1
	. else  if 2=nextplen do
	. . set nextpl=$zpiece(nextp,":",1),nextpu=$zpiece(nextp,":",2)
	. . set:nextpl\1'=nextpl!(nextpl<=0!(nextpu\1'=nextpu!(nextpu<=0!(nextpu<=nextpl)))) $ecode=",U248,"
	. . set nextp1=nextpu+1
	. . set:nextp1>$zlength(newpstr) newpstr=newpstr_$ztranslate($justify("",nextp1-$zlength(newpstr))," ",0)
	. . for j=nextpl+1:1:nextp1 set $zextract(newpstr,j)=1
	. else  set $ecode=",U249,"
	quit newpstr

; This label is intended to only be called internally from XREFDATA, and
; accesses that label's local variables.  Generate cross references for nodes at
; the specified subscript level. It goes through the global at each level with
; fewer subscripts than the cross reference calls for, and where a subtree is
; found, recursively calls itself on that subtree till it reaches the specified
; level, whereon it generates the cross references. Since triggers are set
; before calling this routine, they will take care of cross references for any
; node deletions. This label only needs to be concerned with setting cross
; references for nodes that don't already have cross references, which is done
; in a transaction to ensure Consistency.
xrefdata:(name,gblref,nsubs,sep,pstr,zpiece)
	new i,j,lastsub,nodeval,sublist,thissub,xref
	set thissub=""
	if nsubs>1 do
	. for  set thissub=$order(@gblref@(thissub)) quit:""=thissub  do:$data(@gblref@(thissub))\10 xrefdata(name,$select($qlength(gblref):$zextract(gblref,1,$zlength(gblref)-1)_",",1:gblref_"(")_$zwrite(thissub)_")",nsubs-1,sep,pstr,zpiece)
	else  for  set thissub=$order(@gblref@(thissub)) quit:""=thissub  do
	. tstart ()
	. do:$data(@gblref@(thissub))#10
	. . set nodeval=@gblref@(thissub),sublist=""
	. . for i=1:1:$qlength($reference) set sublist=sublist_","_$zwrite($qsubscript($reference,i))
	. . set lastsub=$qsubscript($reference,$qlength($reference))
	. . if $zlength(sep) for i=2:1:$zlength(pstr) do:+$zextract(pstr,i)
	. . . set j=i-1
	. . . set xref=name_"("_j_","_$zwrite($select(zpiece:$zpiece(nodeval,sep,j),1:$piece(nodeval,sep,j)))_sublist_")"
	. . . set:'$data(@xref)#10 ^(lastsub)=""
	. . else  do
	. . . set xref=name_"("_$zwrite(nodeval)_sublist_")"
	. . . set:'$data(@xref)#10 ^(lastsub)=""
	. tcommit
	quit

;	Error message texts
U248	;"-F-INVPIECE Piece """_nextp_""" is invalid piece specification"
U249	;"-F-INVPSEPLEN Piece number "_i_", "_nextp_" has "_nextplen_" "":"" separated pieces, invalid"
U250	;"-F-NOPIECE Piece separator """_sep_""" specified, but no piece numbers"
U251	;"-F-UNKNERR """_tmp1_""" is not a recognized error code"
U252	;"-F-NOTAGBL Variable """_gbl_""" is not a global variable"
U253	;"-F-NOSUBS Need at least 1 subscript to cross reference; nsubs="_nsubs
U254	;"-F-NOEXTREF Extended reference in "_var_" is not supported"
U255	;"-F-BADINVOCATION Top level invocation of "_$text(+0)_" not supported; must invoke a label"
